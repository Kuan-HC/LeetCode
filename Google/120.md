# 120 楊輝三角II

給定一個非負索引 rowIndex，返回「楊輝三角」的第 rowIndex 行。

在「楊輝三角」中，每個數是它左上方和右上方的數的和。

##  Triangle

Given a triangle array, return the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.

[LeetCode](https://leetcode.cn/problems/triangle/)

### Example 1

<img src="img/119.gif" width = "300"/>

```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```

### Example 2

```
Input: triangle = [[-10]]
Output: -10
``` 

### Constraints

* 1 <= triangle.length <= 200
* triangle[0].length == 1
* triangle[i].length == triangle[i - 1].length + 1
* -104 <= triangle[i][j] <= 10<sup>4</sup>
 
### C++ 

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        /*
            採用另一個vector其形況相同，用來計加到此位置的sum
        */
        vector<int> prior = triangle[0];

        for(int i = 1; i < triangle.size(); ++i){
            vector<int> post(i + 1, 0);
            for(int j = 0; j < post.size(); ++j){
                if(j == 0 )
                    post[j] = triangle[i][j] + prior.front();
                else if(j == post.size() - 1)
                    post[j] = triangle[i][j] + prior.back();
                else    
                    post[j] = triangle[i][j] + min(prior[j - 1], prior[j]);
            }
            prior = move(post);
        }

        return *min_element(prior.begin(), prior.end());
    }
}; 
```
