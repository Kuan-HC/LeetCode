# 080 刪除數組中的重覆項

給定一個單詞數組 words 和一個長度 maxWidth ，重新排版單詞，使其成為每行恰好有 maxWidth 個字符，且左右兩端對齊的文本。

你應該使用 “貪心算法” 來放置給定的單詞；也就是說，盡可能多地往每行中放置單詞。必要時可用空格 ' ' 填充，使得每行恰好有 maxWidth 個字符。

要求盡可能均勻分配單詞間的空格數量。如果某一行單詞間的空格不能均勻分配，則左側放置的空格數要多於右側的空格數。

文本的最後一行應為左對齊，且單詞之間不插入額外的空格。

注意:

* 單詞是指由非空格字符組成的字符序列。
* 每個單詞的長度大於 0，小於等於 maxWidth。
* 輸入單詞數組 words 至少包含一個單詞。


##  Text Justification

Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

[LeetCode](https://leetcode-cn.com/remove-duplicates-from-sorted-array-ii/)

### Example 1

```
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

### Example 2

```
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

``` 

### Constraints

* 1 <= nums.length <= 3 * 10 <sup>4</sup>
* -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
* nums is sorted in non-decreasing order.

### C++ 

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        const int& maxLen = 2;
        int lPtr = 0;
        for(int rPtr = 0; rPtr < nums.size(); ++rPtr){
            if(lPtr < maxLen || nums[lPtr - maxLen] != nums[rPtr]){
                nums[lPtr++] = nums[rPtr];
            }
        }

        return lPtr;
    }
};
```
