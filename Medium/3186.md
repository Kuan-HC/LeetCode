# 3186 Maximum Total Damage With Spell Casting

A magician has various spells.

You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.

It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.

Each spell can be cast only once.

Return the maximum possible total damage that a magician can cast.

[LeetCode](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)

### Example 1

```
Input: power = [1,1,3,4]

Output: 6

Explanation:

The maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.
```

### Example 2

```
Input: power = [7,1,6,6]

Output: 13

Explanation:

The maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.
```

### Constraints

* 1 <= power.length <= 10<sup>5</sup>
* 1 <= power[i] <= 10<sup>9</sup>



### C++ 

```
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        /*
            動態規劃，若現在選的為分數i
            依題目的規定，他只能接在i - 3之後
            而每一種分數都有選或不選兩種
            不選，由前一個分數的選/不選 繼承而來
            選，只能前第i - 2個不選得來
        */
        typedef long long ll;
        map<int, ll> scoreCnt;
        for(const int& num : power)
            scoreCnt[num] += num;
        
        vector<ll> prevOne = {LLONG_MIN, 0, 0}; //分數，選，不選
        vector<ll> prevTwo = {LLONG_MIN, 0, 0};
        
        for(const auto& [num, sum] : scoreCnt){
            vector<ll> curr(3);
            curr[0] = num;
            if(prevOne[0] == num - 2){
                curr[1] = prevOne[2] + sum;
            } else if(prevOne[0] < num - 1){
                curr[1] = max(prevOne[1], prevOne[2]) + sum;
            } else if(prevTwo[0] == num - 2){
                curr[1] = prevTwo[2] + sum;
            } else {
                curr[1] = max(prevTwo[1], prevTwo[2]) + sum;
            }

            curr[2] = max(prevOne[1], prevOne[2]);
            prevTwo = move(prevOne);
            prevOne = move(curr);
        }
        
        return max(prevOne[1], prevOne[2]);
    }
};
```