# 2021 Brightest Position on Street

A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array lights. Each lights[i] = [positioni, rangei] indicates that there is a street lamp at position positioni that lights up the area from [positioni - rangei, positioni + rangei] (inclusive).

The brightness of a position p is defined as the number of street lamp that light up the position p.

Given lights, return the brightest position on the street. If there are multiple brightest positions, return the smallest one.
 
[LeetCode](https://leetcode.cn/problems/brightest-position-on-street/description/)

### Example 1

<img src="img/2021.png" width = "350"/>

```
Input: lights = [[-3,2],[1,2],[3,3]]
Output: -1
Explanation:
The first street lamp lights up the area from [(-3) - 2, (-3) + 2] = [-5, -1].
The second street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].
The third street lamp lights up the area from [3 - 3, 3 + 3] = [0, 6].

Position -1 has a brightness of 2, illuminated by the first and second street light.
Positions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light.
Out of all these positions, -1 is the smallest, so return it.
```

### Example 2

```
Input: lights = [[1,0],[0,1]]
Output: 1
Explanation:
The first street lamp lights up the area from [1 - 0, 1 + 0] = [1, 1].
The second street lamp lights up the area from [0 - 1, 0 + 1] = [-1, 1].

Position 1 has a brightness of 2, illuminated by the first and second street light.
Return 1 because it is the brightest position on the street.
```

### Constraints

* 1 <= lights.length <= 10<sup>5</sup>
* lights[i].length == 2
* -10<sup>8</sup> <= positioni <= 10<sup>8</sup>
* 0 <= rangei <= 10<sup>8</sup>


### C++ 

```
class Solution {
public:
    int brightestPosition(vector<vector<int>>& lights) {
        /*
            使用差分數組的概念，但以map的方式實作
        */
        map<int,int> rangeStart;
        map<int, int> rangeEnd;

        for(const vector<int>& light : lights){
            const int& range = light[1];
            rangeStart[light[0] - range]++;
            rangeEnd[light[0] + range + 1]++;
        }

        int pos = rangeStart.begin()->first;
        map<int,int>::iterator startPtr = rangeStart.begin();
        map<int,int>::iterator endPtr = rangeEnd.begin();
        int maxLight = 0;
        int sum = 0;
        int retPos = pos;

        while(startPtr != rangeStart.end() || endPtr != rangeEnd.end()){
            if(startPtr != rangeStart.end() && pos == startPtr->first){
                sum += startPtr->second;
                ++startPtr;
            }
                
            
            if(endPtr != rangeEnd.end() && pos == endPtr->first){
                sum -= endPtr->second;
                ++endPtr;
            }                

            if(sum > maxLight){
                maxLight = sum;
                retPos = pos;
            }

            //move pos to next point
            if(startPtr != rangeStart.end() && endPtr != rangeEnd.end())
                pos = min(startPtr->first, endPtr->first);
            else if(startPtr != rangeStart.end())
                pos = startPtr->first;
            else if(endPtr != rangeEnd.end())
                pos = endPtr->first;
        }
        
        return retPos;
    }
};
```