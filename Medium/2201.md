# 2201 Count Artifacts That Can Be Extracted

There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:

* (r1i, c1i) is the coordinate of the top-left cell of the ith artifact and
* (r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.
You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.

Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.

The test cases are generated such that:

* No two artifacts overlap.
* Each artifact only covers at most 4 cells.
* The entries of dig are unique.

[LeetCode](https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/description/)

### Example 1

```
Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]
Output: 1
Explanation: 
The different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.
There is 1 artifact that can be extracted, namely the red artifact.
The blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.
Thus, we return 1.
```

### Example 2

```
Input: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]
Output: 2
Explanation: Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. 
```

### Constraints

* 1 <= n <= 1000
* 1 <= artifacts.length, dig.length <= min(n2, 10<sup>5</sup>)
* artifacts[i].length == 4
* dig[i].length == 2
* 0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1
* r1i <= r2i
* c1i <= c2i
* No two artifacts will overlap.
* The number of cells covered by an artifact is at most 4.
* The entries of dig are unique.


### C++ 

```
class Solution {
public:
    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {
        /*
            使用二維prefix，先計下每個位置，並統計二維prefix
            比對每個artifacts的範圍內有多少個點是被挖過的，若一致，代表這個工件可以被挖出來
        */
        vector<vector<int>> prefix(n + 1, vector<int>(n + 1));
        for(const vector<int>& vec : dig)
            prefix[vec[0] + 1][vec[1] + 1] = 1;

        for(int row = 1; row <= n; ++row){
            for(int col = 1; col <= n; ++col)
                prefix[row][col] += prefix[row - 1][col] + prefix[row][col - 1] - prefix[row - 1][col - 1];
        }
        
        int ret = 0;
        for(const vector<int>& artifact : artifacts){
            int&& area = (artifact[2] - artifact[0] + 1) * (artifact[3] - artifact[1] + 1);
            int&& prefixCnt = prefix[artifact[2] + 1][artifact[3] + 1] - prefix[artifact[2] + 1][artifact[1]] \
                                -  prefix[artifact[0]][artifact[3] + 1] + prefix[artifact[0]][artifact[1]];
            if(area == prefixCnt)
                ++ret;
        }

        return ret;
    }
};
```