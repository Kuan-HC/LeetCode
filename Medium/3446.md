# 3446 Sort Matrix by Diagonals

You are given an n x n square matrix of integers grid. Return the matrix such that:

The diagonals in the bottom-left triangle (including the middle diagonal) are sorted in non-increasing order.
The diagonals in the top-right triangle are sorted in non-decreasing order.
 
[LeetCode](https://leetcode.cn/problems/sort-matrix-by-diagonals/description/)

### Example 1

<img src="img/3446_1.png" width = "450"/>

```
Input: grid = [[1,7,3],[9,8,2],[4,5,6]]

Output: [[8,2,3],[9,6,7],[4,5,1]]

Explanation:
The diagonals with a black arrow (bottom-left triangle) should be sorted in non-increasing order:

[1, 8, 6] becomes [8, 6, 1].
[9, 5] and [4] remain unchanged.
The diagonals with a blue arrow (top-right triangle) should be sorted in non-decreasing order:

[7, 2] becomes [2, 7].
[3] remains unchanged.
```

### Example 2

```
Input: grid = [[0,1],[1,2]]

Output: [[2,1],[1,0]]

```

### Constraints

* grid.length == grid[i].length == n
* 1 <= n <= 10
* -10<sup>5<sup> <= grid[i][j] <= 10<sup>5<sup>


### C++ 

```
class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        /*
            按對角線取值，排序
            如何遍歷對角線，左上右下的對角線，其col - row 必為定值
            令右上的第一條線編號為1，則可建立關系為
            k = row - col + colNum
            遍歷k = 1 至 rowNum + colNum - 1
            當col決定則可確定row
            col = row + colNum - k
            當row = 0時，col = colNum - k，
                這個值不會小於0，故row最小值為 max(0, colNum - k)
            當row = rowNum - 1時，col = rowNum - 1 + colNum - k
                這個值不會大於colNum - 1, row最大值為min(colnum - 1, rowNum - 1 + colNum - k)
        */
        const int rowNum = grid.size();
        const int colNum = grid[0].size();

        for(int k = 1; k < rowNum + colNum; ++k){
            int minCol = max(0, colNum - k);
            int maxCol = min(colNum - 1, rowNum + colNum - 1 - k);
            vector<int> nums;
            for(int col = minCol; col <= maxCol; ++col)
                nums.push_back(grid[col + k - colNum][col]);
            
            if(k < (rowNum + colNum) / 2)
                sort(nums.begin(), nums.end());
            else
                sort(nums.begin(), nums.end(), greater<int>());

            for(int col = minCol; col <= maxCol; ++col)
                grid[col + k - colNum][col] = nums[col - minCol];
        }

        return grid;
    }
}; 
```