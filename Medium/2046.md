# 2046 Sort Linked List Already Sorted Using Absolute Values

Given the head of a singly linked list that is sorted in non-decreasing order using the absolute values of its nodes, return the list sorted in non-decreasing order using the actual values of its nodes.

[LeetCode](https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/description/)

### Example 1

```
Input: head = [0,2,-5,5,10,-10]
Output: [-10,-5,0,2,5,10]
Explanation:
The list sorted in non-descending order using the absolute values of the nodes is [0,2,-5,5,10,-10].
The list sorted in non-descending order using the actual values is [-10,-5,0,2,5,10].
```

### Example 2

```
Input: head = [0,1,2]
Output: [0,1,2]
Explanation:
The linked list is already sorted in non-decreasing order.
```

### Constraints

* The number of nodes in the list is the range [1, 10<sup>5</sup>].
* -5000 <= Node.val <= 5000
* head is sorted in non-decreasing order using the absolute value of its nodes.


### C++ 

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortLinkedList(ListNode* head) {
        /*
            將鏈表拆正正數的表以及負數的表，之後將負數的表逆序以後與正表相連
        */
        ListNode* posDummy = new ListNode(0);
        ListNode* posTail = posDummy;
        ListNode* negDummy = new ListNode(0);
        ListNode* negTail = negDummy;

        while(head){
            if(head->val >= 0){
                posTail->next = head;
                posTail = posTail->next;
            } else {
                negTail->next = head;
                negTail = negTail->next; 
            }
            head = head->next;
        }
        posTail->next = nullptr;
        negTail->next = nullptr;

        if(negDummy->next == nullptr)
            return posDummy->next;

        //逆序負的鍊表
        
        ListNode* revHead = nullptr;
        ListNode* root = negDummy->next;
        while(root){
            ListNode* tmp = root;
            root = root->next;
            tmp->next = revHead;
            revHead = tmp;
        }
        negDummy->next->next = posDummy->next;

        return revHead;        
    }
};
```