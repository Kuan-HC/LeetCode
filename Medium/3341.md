# 3341 Find Minimum Time to Reach Last Room I

There is a dungeon with n x m rooms arranged as a grid.

You are given a 2D array moveTime of size n x m, where moveTime[i][j] represents the minimum time in seconds after which the room opens and can be moved to. You start from the room (0, 0) at time t = 0 and can move to an adjacent room. Moving between adjacent rooms takes exactly one second.

Return the minimum time to reach the room (n - 1, m - 1).

Two rooms are adjacent if they share a common wall, either horizontally or vertically.

[LeetCode](https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/)

### Example 1

```
Input: moveTime = [[0,4],[4,4]]

Output: 6

Explanation:

The minimum time required is 6 seconds.

At time t == 4, move from room (0, 0) to room (1, 0) in one second.
At time t == 5, move from room (1, 0) to room (1, 1) in one second.
```

### Example 2

```
Input: moveTime = [[0,0,0],[0,0,0]]

Output: 3

Explanation:

The minimum time required is 3 seconds.

At time t == 0, move from room (0, 0) to room (1, 0) in one second.
At time t == 1, move from room (1, 0) to room (1, 1) in one second.
At time t == 2, move from room (1, 1) to room (1, 2) in one second.
```

### Constraints

* 2 <= n == moveTime.length <= 50
* 2 <= m == moveTime[i].length <= 50
* 0 <= moveTime[i][j] <= 10<sup>9</sup>


### C++ 

```
class Solution {
protected:
    typedef pair<int,int> iPair;
    struct cmp{
        bool operator()(const iPair& lhs, const iPair& rhs)const{
            return lhs.first >= rhs.first;
        }
    };
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        /*
            當某位置已經訪問過，經該位置的時間設為-1
            以dijkstra排序，時間愈早的排愈前面
            以哈希表記下位置 hash = 51 * row + col

        */
        
        int moves[4][2] = {{-1,0}, {1,0}, {0,-1},{0,1}};
        int rowNum = moveTime.size();
        int colNum = moveTime[0].size();
        priority_queue<iPair, vector<iPair>, cmp> priQue;
        priQue.emplace(0, 0);
        moveTime[0][0] = -1;

        while(!priQue.empty()){
            iPair curr = priQue.top();
            priQue.pop();

            int&& row = curr.second / 51;
            int&& col = curr.second % 51;
            
            for(int i = 0; i < 4; ++i){
                int&& nextRow = row + moves[i][0];
                int&& nextCol = col + moves[i][1];
                if(nextRow < 0 || nextRow >= rowNum || nextCol < 0 || nextCol >= colNum || moveTime[nextRow][nextCol] == -1)
                    continue;
                
                int&& time = max(curr.first, moveTime[nextRow][nextCol]) + 1;
                if(nextRow == rowNum - 1 && nextCol == colNum - 1)
                    return time;
                moveTime[nextRow][nextCol] = -1;    
                priQue.emplace(time, nextRow * 51 + nextCol);
            } 
        }
       
        return -1;
    }
};
```