# 2054 Two Best Non-Overlapping Events

You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.

Return this maximum sum.

Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.
 
[LeetCode](https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)

### Example 1


<img src="img/2054_1.png" width = "300"/>

```
Input: events = [[1,3,2],[4,5,2],[2,4,3]]
Output: 4
Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.
```

### Example 2

<img src="img/2054_2.png" width = "300"/>

```
Input: events = [[1,3,2],[4,5,2],[1,5,5]]
Output: 5
Explanation: Choose event 2 for a sum of 5.
```

### Constraints

* 2 <= events.length <= 10<sup>5</sup>
* events[i].length == 3
* 1 <= startTimei <= endTimei <= 10<sup>9</sup>
* 1 <= valuei <= 10<sup>6</sup>


### C++ 

```
class Solution {
protected:
    typedef pair<int,int> iPair;
    static bool cmp(const vector<int>& lhs, const vector<int>& rhs){
        return lhs[1] < rhs[1];
    }
public:
    int maxTwoEvents(vector<vector<int>>& events) {
        /*
            題目要求只找出1/2個活動
            遍歷每一個活動，找出右側能搭配的最大值
            1. 以優先隊列儲存，值大的在上面，並包含啟始位置
            2. 對數列排序，以結尾小的排序
            3. 遍歷排序後的，並搭配最的的右側值
        */
        
        priority_queue<iPair> priQue;
        for(const vector<int>& event : events)
            priQue.emplace(event[2], event[0]);
        
        sort(events.begin(), events.end(), cmp);
        int ret = 0;
        for(const vector<int>& event : events){
            while(!priQue.empty() && priQue.top().second <= event[1])
                priQue.pop();
            int&& sum = event[2] + (priQue.empty()? 0 : priQue.top().first);
            ret = max(ret, sum);
        }

        return ret;
    }
};
```