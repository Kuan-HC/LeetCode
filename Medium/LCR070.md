# LCR070 三數之和

給定一個包含 n 個整數的數組 nums，判斷 nums 中是否存在三個元素 a ，b ，c ，使得 a + b + c = 0 ？請找出所有和為 0 且 不重覆 的三元組。
 
[LeetCode](https://leetcode.cn/problems/3sum/description/)

### Example 1

```
輸入：nums = [-1,0,1,2,-1,-4]
輸出：[[-1,-1,2],[-1,0,1]]
解釋：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元組是 [-1,0,1] 和 [-1,-1,2] 。
注意，輸出的順序和三元組的順序並不重要。
```

### Example 2

```
輸入：nums = [0,1,1]
輸出：[]
解釋：唯一可能的三元組和不為 0 。
```

### Constraints

* 3 <= nums.length <= 3000
* -10<sup>5</sup> <= nums[i] <= 10<sup>5</sup>

### C++ 

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ret;
        int&& len = nums.size();
        for(int i = 0; i < len; ++i){
            if(nums[i] > 0)
                break;
            if(i > 0 && nums[i] == nums[i - 1])
                continue;

            int&& target = -nums[i];
            int left = i + 1;
            int&& right = len - 1;
            while(left < right){
                int&& sum = nums[left] + nums[right];
                if( sum > target){
                    --right;
                } else if(sum < target){
                    ++left;
                } else {
                    ret.emplace_back(vector<int>{nums[left], nums[right], nums[i]});                    
                    while(left < right && nums[left] == nums[++left]);
                    while(left < right && nums[right] == nums[--right]);
                }
            } 
        }
        
        return ret;
    }
};
```