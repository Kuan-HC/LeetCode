# 2023 Number of Pairs of Strings With Concatenation Equal to Target

Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.
 
[LeetCode](https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/)

### Example 1

```
Input: nums = ["777","7","77","77"], target = "7777"
Output: 4
Explanation: Valid pairs are:
- (0, 1): "777" + "7"
- (1, 0): "7" + "777"
- (2, 3): "77" + "77"
- (3, 2): "77" + "77"
```

### Example 2

```
Input: nums = ["123","4","12","34"], target = "1234"
Output: 2
Explanation: Valid pairs are:
- (0, 1): "123" + "4"
- (2, 3): "12" + "34"
```

### Constraints

* 2 <= nums.length <= 100
* 1 <= nums[i].length <= 100
* 2 <= target.length <= 100
* nums[i] and target consist of digits.
* nums[i] and target do not have leading zeros.


### C++ 

```
class Solution {
public:
    int numOfPairs(vector<string>& nums, string target) {
        /*
            記下每個字符串出現的次數
            但要特別處理當前後段一樣時的情形
        */
        unordered_map<string, int> strCnt;
        for(const string& str : nums)
            strCnt[str]++;
        int ret = 0;
        for(int prevLen= 1; prevLen < target.length(); ++prevLen){
            string prevStr = target.substr(0, prevLen);
            string postStr = target.substr(prevLen);
            if(strCnt.contains(prevStr) && strCnt.contains(postStr)){
                int prevCnt = strCnt[prevStr];
                strCnt[prevStr]--;
                ret += prevCnt * strCnt[postStr];
                strCnt[prevStr]++;
            }
        }
        
        return ret;
    }
};
```