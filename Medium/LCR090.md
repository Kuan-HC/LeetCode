# LCR090 打家劫舍 II

一個專業的小偷，計劃偷竊一個環形街道上沿街的房屋，每間房內都藏有一定的現金。這個地方所有的房屋都 圍成一圈 ，這意味著第一個房屋和最後一個房屋是緊挨著的。同時，相鄰的房屋裝有相互連通的防盜系統，如果兩間相鄰的房屋在同一晚上被小偷闖入，系統會自動報警 。

給定一個代表每個房屋存放金額的非負整數數組 nums ，請計算 在不觸動警報裝置的情況下 ，今晚能夠偷竊到的最高金額。
 
[LeetCode](https://leetcode.cn/problems/PzWKhm/)

### Example 1

```
輸入：nums = [2,3,2]
輸出：3
解釋：你不能先偷竊 1 號房屋（金額 = 2），然後偷竊 3 號房屋（金額 = 2）, 因為他們是相鄰的。
```

### Example 2

```
輸入：nums = [1,2,3,1]
輸出：4
解釋：你可以先偷竊 1 號房屋（金額 = 1），然後偷竊 3 號房屋（金額 = 3）。
     偷竊到的最高金額 = 1 + 3 = 4 。
```

### Constraints

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 1000

### C++ 

```
class Solution {
protected:
    int robSec(const vector<int>& nums, int start, int end){
        int prevWoRob = 0;
        int prevWiRob = nums[start++];
        for(; start < end; ++start){
            int&& wiRob = prevWoRob + nums[start];
            prevWoRob =  max(prevWoRob, prevWiRob);
            prevWiRob = move(wiRob);
        }

        return max(prevWoRob, prevWiRob);
    }
public:
    int rob(vector<int>& nums) {
        /*
            因為是環形，所以若第一家偷，最後一家就不能偷
            找出兩個區間的最大值
        */
        const int len = nums.size();
        if(len == 1)
            return nums.front();
            
        return max(robSec(nums, 0, len - 1) , robSec(nums, 1, len));
    }
};
```