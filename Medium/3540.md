# 3540 Minimum Time to Visit All Houses

You are given two integer arrays forward and backward, both of size n. You are also given another integer array queries.

There are n houses arranged in a circle. The houses are connected via roads in a special arrangement:

* For all 0 <= i <= n - 2, house i is connected to house i + 1 via a road with length forward[i] meters. Additionally, house n - 1 is connected back to house 0 via a road with length forward[n - 1] meters, completing the circle.
* For all 1 <= i <= n - 1, house i is connected to house i - 1 via a road with length backward[i] meters. Additionally, house 0 is connected back to house n - 1 via a road with length backward[0] meters, completing the circle.
You can walk at a pace of one meter per second. Starting from house 0, find the minimum time taken to visit each house in the order specified by queries.

Return the minimum total time taken to visit the houses.
 
[LeetCode](https://leetcode.cn/problems/minimum-time-to-visit-all-houses/)

### Example 1

```
Input: forward = [1,4,4], backward = [4,1,2], queries = [1,2,0,2]

Output: 12

Explanation:

The path followed is 0(0) → 1(1) →​​​​​​​ 2(5) → 1(7) →​​​​​​​ 0(8) → 2(12).

Note: The notation used is node(total time), → represents forward road, and → represents backward road.
```

### Example 2

```
Input: forward = [1,1,1,1], backward = [2,2,2,2], queries = [1,2,3,0]

Output: 4

Explanation:

The path travelled is 0 →​​​​​​​ 1 →​​​​​​​ 2 →​​​​​​​ 3 → 0. Each step is in the forward direction and requires 1 second.
```

### Constraints

* 2 <= n <= 10<sup>5<sup>
* n == forward.length == backward.length
* 1 <= forward[i], backward[i] <= 10<sup>5<sup>
* 1 <= queries.length <= 10<sup>5<sup>
* 0 <= queries[i] < n
* queries[i] != queries[i + 1]
* queries[0] is not 0.


### C++ 

```
class Solution {
public:
    long long minTotalTime(vector<int>& forward, vector<int>& backward, vector<int>& queries) {
        /*
            每次移動的方式都有兩種，forward / backward
            forward時，若目標點編號大於現在位置則需時time[target] - time[curr]
            若目標編號小於現在位置則需時time[target] + time[繞一圈到0點] - time[curr]
            使用prefix記下加速
            反向也是一樣，若目前的位置所花時間是最優，下一點選擇正向/反向的最優解
            e.g. forward = [1,4,4] -> prefix[0,1,5,9] 
                 從0 走到2 = pref[2] - pref[0] 從2走到1 = pref[3] - pref[2] + pref[1] 
                 backward = [4,1,2] -> prefix[0,1,3,7]
                 從2到到0 = pref[2] - pref[0]  從1走到2 = pref[1] + pref[3] - pref[2]
                 
        */
        const int len = forward.size();
        long long ret = 0;
        vector<long long> forwardPrefix(len + 1), backwardPrefix(len + 1);
        for(int i = 1; i <= len; ++i)
            forwardPrefix[i] = forward[i - 1] + forwardPrefix[i - 1];
        for(int i = 1; i < len; ++i)
            backwardPrefix[i] = backward[i] + backwardPrefix[i - 1];
        backwardPrefix[len] = backward[0] + backwardPrefix[len - 1];

        int currPos = 0;
        for(int i = 0; i < queries.size(); ++i){
            const int& nextPos = queries[i];
            long long forwardTime = 0;
            long long backwardTime = 0;
            if(nextPos >= currPos){
                forwardTime = forwardPrefix[nextPos] - forwardPrefix[currPos];
                backwardTime = backwardPrefix.back() - backwardPrefix[nextPos] + backwardPrefix[currPos];
            } else {
                forwardTime = forwardPrefix.back() - forwardPrefix[currPos] + forwardPrefix[nextPos];
                backwardTime = backwardPrefix[currPos] - backwardPrefix[nextPos];
            }
            ret += forwardTime <= backwardTime? forwardTime : backwardTime;
            currPos = nextPos;
        }

        return ret;        
    }
};
```