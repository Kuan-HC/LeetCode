# 3170 Lexicographically Minimum String After Removing Stars

You are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.

While there is a '*', do the following operation:

Delete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.
Return the lexicographically smallest resulting string after removing all '*' characters.
 
[LeetCode](https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros/description/)

### Example 1

```
Input: s = "aaba*"

Output: "aab"

Explanation:

We should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.
```

### Example 2

```
Input: s = "abc"

Output: "abc"

Explanation:

There is no '*' in the string.
```

### Constraints

* 1 <= s.length <= 105
* s consists only of lowercase English letters and '*'.
* The input is generated such that it is possible to delete all '*' characters.

### C++ 

```
class Solution {
public:
    string clearStars(string s) {
        /*
            使用優先隊列，依字典序及位置排序
            字典序愈小愈上面，若字典序相同，位置愈大的愈上面
        */
        auto cmp = [](const int& lhs, const int& rhs){
            int&& lhsChr = lhs % 26;
            int&& rhsChr = rhs % 26;
            if(lhsChr == rhsChr)
                return lhs / 26 < rhs / 26;
            
            return lhsChr > rhsChr;
        };
        priority_queue<int, vector<int>, decltype(cmp)> priQue;

        for(int i = 0; i < s.length(); ++i){
            if(s[i] != '*'){
                priQue.push(i * 26 + s[i] - 'a');
            } else {
                int hashChr = priQue.top();
                priQue.pop();
                s[hashChr / 26] = '_';
            }
        }

        string ret;
        for(const char& chr : s){
            if(isalpha(chr))
                ret.push_back(chr);
        }


        return ret;
        
    }
};
```